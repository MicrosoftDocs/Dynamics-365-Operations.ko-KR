---
title: 다운타임 없이 맞춤형 X++ 스크립트 실행
description: 이 항목에서는 시스템을 일시 중단하지 않고 사용자 지정 X++ 스크립트가 포함된 배포 가능한 패키지를 업로드하고 실행하는 방법에 대해 설명합니다.
author: AndersGirke
ms.date: 12/16/2021
ms.topic: article
ms.search.form: ''
audience: Application User
ms.reviewer: kamaybac
ms.search.region: Global
ms.author: aevengir
ms.search.validFrom: 2021-12-16
ms.dyn365.ops.version: 10.0.25
ms.openlocfilehash: fcd0a472fa5116ca0b3a59561b6eeb72181a9113
ms.sourcegitcommit: 44e6875e974a3a1b3e1d7a24c1a3cff3d3697cdc
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 02/03/2022
ms.locfileid: "8461041"
---
# <a name="run-custom-x-scripts-with-zero-downtime"></a>다운타임 없이 맞춤형 X++ 스크립트 실행

[!include [banner](../includes/banner.md)]
[!INCLUDE [preview-banner](../includes/preview-banner.md)]

이 기능을 사용하면 Microsoft Dynamics Lifecycle Services(LCS)를 중단하거나 시스템을 일시 중단할 필요 없이 사용자 지정 X++ 스크립트가 포함된 배포 가능한 패키지를 업로드하고 실행할 수 있습니다. 따라서 중단 시간을 일으키지 않고 사소한 데이터 불일치를 수정할 수 있습니다.

사소한 데이터 불일치를 수정하기 위해 X++ 스크립트를 사용하는 이점은 스크립트를 실행할 때 시스템이 필요에 따라 모든 관련 테이블을 자동으로 조정한다는 것입니다. 이 접근 방식은 수정의 무결성을 보장하고 새로운 불일치가 발생할 위험을 최소화하는 데 도움이 됩니다.

> [!IMPORTANT]
> 이 기능은 사소한 데이터 불일치 수정만을 위한 것입니다. 다음과 같은 목적이나 다른 용도로 사용해서는 안 됩니다.
>
> - 데이터 수집
> - 스키마 변경
> - 데이터 마이그레이션 또는 기타 장기 실행 프로세스
> - 일반 비즈니스 프로세스, 데이터 일관성 도구 또는 기타 셀프 서비스 도구와 같은 다른 수단을 통해 수정할 수 있는 데이터 수정
>
> 이 기능을 사용하면 권한 있는 사용자가 해당 엔터티와 연결된 비즈니스 논리를 실행할 필요 없이 엔터티 및 해당 레코드를 직접 변경할 수 있습니다. 이러한 변경으로 인해 데이터 무결성 문제가 발생할 수 있습니다. 따라서 조직에서는 스크립트를 실행하기 전후에 내부 및 외부 감사자(또는 기타 동등한 이해 관계자)로부터 승인 및 승인을 받아야 할 수 있습니다. 규정 준수를 위해 일부 특성에 영향을 미치는 변경 사항은 재무제표와 같은 외부 보고서에 공개하거나 정부 기관에 보고해야 할 수도 있습니다. 귀하의 조직은 이 기능을 통한 데이터 변경, 해당 변경의 승인 및 승인 또는 공개, 관련 법률 준수에 대해 전적인 책임을 집니다. 이 기능을 사용하는 데 따른 모든 위험은 귀하가 부담합니다.

시스템에 업로드되는 모든 배포 가능한 패키지는 필수 워크플로를 거칩니다. 안전 예방책과 업무 분리를 보장하기 위해 배포 가능한 패키지를 업로드하는 사용자는 워크플로의 다음 단계에서 해당 패키지를 승인할 수 없습니다. 다른 사용자가 승인해야 합니다. 그러나 패키지가 승인된 후에는 패키지를 업로드한 사용자가 나머지 단계를 완료할 수 있습니다.

시스템에서는 배포 가능한 모든 패키지가 테스트 실행을 거쳐야 합니다. 프로덕션 데이터에서 스크립트를 실행하기 전에 사용자는 **테스트 로그 수락** 을 선택하여 출력이 올바른지 확인해야 합니다. 출력이 올바르지 않으면 사용자는 **폐기** 를 선택하여 패키지를 실패한 것으로 표시해야 합니다. 이 경우 스크립트는 프로덕션 데이터에서 실행할 수 없습니다.

업로드된 모든 패키지는 시스템에 저장되고 정의된 이벤트 워크플로를 거칩니다. 각 이벤트에 대해 시스템은 타임스탬프와 이벤트를 수행한 사람의 ID를 포함하는 로그를 유지합니다. 이러한 방식으로 시스템은 감사 추적이 있는지 확인합니다.

다음 그림에서 볼 수 있듯이 시스템은 배포 가능한 각 패키지가 X++에서 실행된 방법과 어떤 엔터티가 터치되었는지에 대한 세부 정보를 제공합니다.

![스크립트 세부 정보 페이지.](media/script-details.png "스크립트 세부 정보 페이지")

## <a name="assign-duties-to-users-to-control-access"></a>액세스를 제어하기 위해 사용자에게 의무 할당

이 기능은 다음과 같은 의무를 제공합니다. 관리자는 이러한 의무를 사용하여 기능에 대한 액세스를 제어할 수 있습니다.

- **사용자 정의 스크립트 유지 관리** – 이 의무는 환경에서 사용자 정의 X++ 스크립트를 업로드, 테스트, 확인 및 실행할 수 있는 기능을 부여합니다(사용자 승인 테스트 \[UAT\] 및 생산).
- **사용자 정의 스크립트 승인** – 이 의무는 업로드된 사용자 지정 X++ 스크립트를 승인할 수 있는 권한을 부여합니다. 승인은 스크립트를 테스트, 확인 및 실행하기 전에 필수 단계입니다.

악의적인 작업의 위험을 최소화하려면 각 스크립트를 업로드한 사용자가 아닌 다른 사용자가 명시적으로 승인해야 합니다. 조직에서 이 기능을 사용하려면 먼저 관리자가 관련성이 높고 신뢰할 수 있는 사용자 두 명 이상에게 선행 작업을 할당해야 합니다. 단일 사용자가 두 가지 의무를 모두 가질 수 있지만 해당 사용자는 여전히 자신의 스크립트를 승인할 수 없습니다.

## <a name="create-a-deployable-package"></a>배포 가능한 패키지 만들기

이 기능을 사용하려면 Visual Studio에서 생성할 수 있는 일반 배포 가능한 패키지가 필요합니다. 지침은 [배포 가능한 모델 패키지 생성](../deployment/create-apply-deployable-package.md)을 참조하세요.

배포 가능한 패키지는 정확히 하나의 실행 가능한 X++ 클래스를 포함해야 합니다. 즉, 다음과 같은 서명이 있는 메서드를 포함하는 클래스가 하나 있어야 합니다.

```xpp
public static void main(Args _args)
```

> [!NOTE]
> 기본 메서드의 이름은 소문자여야 합니다.

## <a name="code-example"></a>코드 예

다음 코드 예제에서는 배포 가능한 패키지를 구성하는 방법을 보여줍니다.

```xpp
class MyScriptClassForIssueXYZ
{
    public static void main(Args _args)
    {
        if (curExt() != 'DAT')
        {
            throw error("This script must run in the DAT company!");
        }

        ttsbegin;

        MyTable myTable;

        update_recordset myTable
            setting myField = 17
            where myTable.myReference == 'xyz';

        if (myTable.RowCount() != 1)
        {
            throw error("Not updating the expected row!");
        }

        info("Success");
  
        ttscommit;
    }

}
```

## <a name="best-practices"></a>모범 사례

다음 목록은 스크립트를 성공적으로 작성, 구현 및 실행하기 위한 몇 가지 모범 사례를 설명합니다. 이 목록은 완전한 것이 아니며 단지 지침으로 간주되어야 합니다.

- 스크립트 끝에 성공 메시지를 작성 **합니다**. 이런 식으로 스크립트가 예외 없이 실행되었음을 확인할 수 있습니다.
- 트랜잭션 범위의 명시적 처리를 추가 **합니다**.
- `update()` 메서드와 같은 기존 비즈니스 로직을 사용 **하고** `doUpdate()`, `doInsert()`, `doDelete()` 메서드를 사용하여 비즈니스 로직을 우회하지 **않습니다**. 이 접근 방식은 종속 데이터가 올바르게 처리되도록 하는 데 도움이 됩니다. 또한 추가 데이터 불일치의 위험을 크게 줄일 수 있습니다.
- 회사 컨텍스트를 주장 **합니다**. 이 접근 방식은 스크립트가 실행될 때 일반적인 실수를 노출합니다. 예를 들어 스크립트가 잘못된 회사에서 실행되고 있는지 여부를 나타냅니다.
- 영향을 받는 레코드 수가 예상과 일치하는지 확인 **합니다**. 이 접근 방식은 스크립트가 준비되는 동안 시스템에서 데이터가 예기치 않게 이동되었는지 여부를 나타냅니다.
- 각 스크립트에 고유한 클래스 이름을 사용 **합니다**(예: 이름에 작업 항목에 대한 참조 포함). 이 접근 방식은 스크립트를 업로드할 때 이름 충돌 문제를 방지합니다. 스크립트의 새 반복이 필요한 경우 새 이름을 지정해야 합니다.
- 먼저 비프로덕션 환경에서 각 스크립트를 테스트 **합니다**. 관련 데이터에 대한 의도된 영향 및 의도하지 않은 부작용에 대해 테스트합니다. 영향을 받을 수 있는 모든 비즈니스 프로세스가 이후에 성공적으로 완전히 완료될 수 있는지 확인합니다.

## <a name="upload-and-run-a-deployable-package"></a>배포 가능한 패키지 업로드 및 실행

다음 절차에 따라 스크립트를 업로드 및 실행합니다.

1. 재무 및 운영 앱에서 **시스템 관리 \> 정기 작업 \> 데이터 베이스 \> 사용자 정의 스크립트** 로 이동합니다.
1. **업로드** 를 선택합니다.
1. 이 항목의 앞부분에서 설명한 대로 생성한 배포 가능한 패키지를 선택합니다. 스크립트의 목적을 지정하라는 메시지가 표시됩니다.
1. 이제 스크립트를 업로드한 사용자가 아닌 다른 사용자가 스크립트를 승인해야 합니다. 승인자는 다음 단계를 따라야 합니다.

    1. **시스템 관리 \> 정기 \> 데이터베이스 \> 사용자 정의 스크립트** 로 이동합니다.
    1. 승인할 스크립트를 선택한 다음 **세부 정보** 를 선택합니다.
    1. 작업 창에서 **프로세스 워크플로** 탭의 **시작** 그룹에서 **승인** 또는 **거부** 를 선택합니다. **승인** 을 선택하면 스크립트는 승인된 것으로 표시되고 테스트를 위해 잠금 해제됩니다. **거부** 를 선택하면 스크립트가 잠겨 있습니다. 두 경우 모두 이벤트가 기록되고 스크립트 사본이 시스템에 보관됩니다.

1. 스크립트가 의도한 대로 수행되는지 확인하려면 스크립트를 테스트해야 합니다. 테스터는 업로더 또는 승인자와 동일하거나 필요한 권한이 있는 세 번째 사용자일 수 있습니다. 테스터는 다음 단계를 따라야 합니다.

    1. **시스템 관리 \> 정기 \> 데이터베이스 \> 사용자 정의 스크립트** 로 이동합니다.
    1. 테스트할 스크립트를 선택한 다음 **세부 정보** 를 선택합니다.
    1. 작업 창의 **프로세스 워크플로** 탭에서 **테스트** 그룹에 있는 **테스트 실행** 을 선택합니다. 스크립트는 다양한 로그와 SQL 문을 수집하는 동안 시스템이 자동으로 중단할 임시 트랜잭션 내에서 실행됩니다.
    1. 스크립트 실행이 완료되면 로그를 검토하고 결과가 기대치를 충족하는지 확인합니다. 다음 단계 중 하나를 따르십시오.

        - 테스트 결과가 만족스러우면 **테스트 로그 수락** 을 **테스트** 그룹의 **프로세스 워크플로** 탭이 있는 작업 창에서 선택하여 스크립트를 실행할 수 있도록 합니다. 이벤트 로그는 스크립트가 테스트되었다는 사실을 반영하고 누가 언제 테스트했는지 표시합니다.
        - 테스트 결과가 만족스럽지 않으면 **취소** 를 **종료** 그룹의 **프로세스 워크플로** 탭이 있는 작업 창에서 선택하여 스크립트를 실행하지 못하도록 합니다. 시스템은 스크립트 사본을 기록 로그와 함께 보관합니다.

1. 스크립트가 기대에 부합한다고 확신하면 작업 창의 **프로세스 워크플로** 탭에 있는 **실행** 그룹에서 **실행** 을 선택하여 실행합니다. 이 명령은 이전 테스트 실행과 동일한 작업을 수행하지만 마지막에 트랜잭션이 커밋됩니다.
1. 스크립트 실행이 완료된 후 결과를 확인하고 스크립트가 의도한 대로 작동하는지 확인합니다. 다음 단계 중 하나를 따르십시오.

    - 결과에 만족하면 작업 창의 **프로세스 워크플로** 탭에서 **종료** 그룹의 **목적 해결** 을 선택합니다. 이벤트 로그는 스크립트가 실행되었다는 사실을 반영하고 누가 언제 인증했는지 표시합니다. 스크립트가 저장되었지만 이제 잠겨 있어 다시 실행할 수 없습니다.
    - 결과에 만족하지 않으면 작업 창의 **프로세스 워크플로** 탭에서 **종료** 그룹의 **목적 미해결** 을 선택합니다. 이벤트 로그는 스크립트가 실행되지 않아 의도된 목적을 실행하지 못했다는 사실을 반영하고 누가 언제 실행했는지 표시합니다. 스크립트가 저장되었지만 이제 잠겨 있어 다시 실행할 수 없습니다. 그러나 시스템은 스크립트 작업을 자동으로 실행 취소하지 않습니다. 실패한 스크립트가 시스템에 미친 영향을 취소하려면 새 스크립트를 작성, 가져오기 및 실행해야 할 수 있습니다.

마지막 단계에서 선택한 항목에 따라 스크립트의 최종 상태가 정의됩니다. 필요에 따라 프로세스를 반복할 수 있습니다.

## <a name="upload-and-run-a-deployable-package-through-lcs"></a>LCS를 통해 배포 가능한 패키지 업로드 및 실행

이전 섹션에서 설명한 대로 재무 및 운영 앱의 사용자 인터페이스를 통해 배포 가능한 패키지를 배포하는 대신 LCS에 업로드하고 일반 절차를 사용하여 배포할 수 있습니다. 자세한 내용은 [명령줄에서 배포 가능한 패키지 설치](../deployment/install-deployable-package.md)를 참조하세요.

이 접근 방식은 제한 사항이 적지만 오류 보호 기능은 적습니다. 또한 모든 서버를 다시 시작해야 하기 때문에 약간의 다운타임이 발생합니다.
